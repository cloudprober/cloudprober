syntax = "proto2";

package cloudprober;

import "github.com/cloudprober/cloudprober/probes/proto/config.proto";
import "github.com/cloudprober/cloudprober/targets/endpoint/proto/endpoint.proto";

option go_package = "github.com/cloudprober/cloudprober/prober/proto";

service Cloudprober {
  // AddProbe adds a probe to cloudprober. Error is returned if probe is already
  // defined or there is an error during initialization of the probe.
  rpc AddProbe(AddProbeRequest) returns (AddProbeResponse) {}

  // RemoveProbe stops the probe and removes it from the in-memory database.
  rpc RemoveProbe(RemoveProbeRequest) returns (RemoveProbeResponse) {}

  // EXPERIMENTAL. It's still in development. Implementation subject to change.
  // RunProbe runs all or subset of probes this instance is configured with.
  rpc RunProbe(RunProbeRequest) returns (RunProbeResponse) {}

  // ListProbes lists active probes.
  rpc ListProbes(ListProbesRequest) returns (ListProbesResponse) {}

  rpc SaveProbesConfig(SaveProbesConfigRequest) returns (SaveProbesConfigResponse) {}

  // GetProbeStatus returns the ongoing probe status data, including
  // total/success counters per probe/target, with optional per-minute
  // breakdown.
  rpc GetProbeStatus(GetProbeStatusRequest) returns (GetProbeStatusResponse) {}
}

message AddProbeRequest {
  optional probes.ProbeDef probe_config = 1;
}

message AddProbeResponse {}

message RemoveProbeRequest {
  optional string probe_name = 1;
}

message RemoveProbeResponse {}

message RunProbeRequest {
  // If empty, all configured probes are run.
  repeated string probe_name = 1;

  // Note: we may support overriding the targets or other fields in the
  // future.
}

// TODO: Add metrics handling.
message ResultMetric {
}

// Results of a single probe run for a given target.
message ProbeRunResult {
  // Target that this result is associated with.
  required cloudprober.targets.Endpoint target = 1;

  // True if the probe run was successful.
  required bool success = 2;

  // Latency in microseconds. Set for successful probes.
  optional int64 latency_usec = 3;

  // Additional metrics from the probe run.
  repeated ResultMetric result_metrics = 4;

  // Optional error message for failed probes.
  optional string error = 5;
}

message ProbeResults {
  repeated ProbeRunResult run_result = 1;
}

message RunProbeResponse {
  map<string, ProbeResults> results = 1;
}

message ListProbesRequest {}

message Probe {
  optional string name = 1;
  optional probes.ProbeDef config = 2;
}

message ListProbesResponse {
  repeated Probe probe = 1;
}

message SaveProbesConfigRequest {
  // File path to save probes config to. Default is configured through the
  // command-line flag: --probes_config_save_path
  optional string file_path = 1;
}

message SaveProbesConfigResponse {
  optional string file_path = 1;
}

message GetProbeStatusRequest {
  // If empty, status for all probes is returned.
  repeated string probe_name = 1;

  // Time window in minutes to compute aggregated stats for. Default is 10.
  optional int32 time_window_minutes = 2 [default = 10];
}

message GetProbeStatusResponse {
  repeated ProbeStatus probe_status = 1;
}

message ProbeStatus {
  optional string name = 1;
  repeated TargetStatus target_status = 2;
}

message TargetStatus {
  optional string target_name = 1;
  optional int64 total = 2;
  optional int64 success = 3;
  // Per-minute breakdown, only populated if per_minute_breakdown is true in
  // the request.
  repeated MinuteStatus minute_status = 5;
}

message MinuteStatus {
  // Unix timestamp in seconds for this minute bucket.
  optional int64 timestamp = 1;
  optional int64 total = 2;
  optional int64 success = 3;
}
