// Copyright 2025 The Cloudprober Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// genprotofacade generates a Go file that exports symbols from the given proto
// files. It is used to generate a facade for the cloudprober protobufs.
package main

import (
	"flag"
	"fmt"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

var (
	protoroot = flag.String("protoroot", "", "Root directory to scan for */proto (required)")
	out       = flag.String("out", "", "Output file path (required)")
	module    = flag.String("module", "github.com/cloudprober/cloudprober", "Go module path (e.g. github.com/cloudprober/cloudprober)")
)

type ReExport struct {
	Alias       string
	Original    string
	ImportAlias string
}

type TemplateData struct {
	Root            string
	Module          string
	OutPackage      string
	Imports         []Import
	ReExportOrder   []string
	ImportReExports map[string][]ReExport
}

type Import struct {
	Alias string
	Path  string
}

var tmpl = template.Must(template.New("facade").Parse(`// Code generated by genprotofacade; DO NOT EDIT.
//go:generate go run {{.Module}}/tools/genprotofacade -protoroot={{.Root}} -out=$GOFILE

package {{.OutPackage}}

{{ range .Imports -}}
import {{ .Alias }} "{{ .Path }}"
{{ end }}

{{- $importReExports := .ImportReExports }}
{{ range $v := .ReExportOrder -}}
// Symbols from {{ $v }}
{{ range (index $importReExports $v) -}}
type {{ .Alias }} = {{ .ImportAlias }}.{{ .Original }}
{{ end }}
{{ end }}
`))

// findModuleRoot finds the root directory of the current Go module.
func findModuleRoot() (string, error) {
	// Start from the current working directory
	wd, err := os.Getwd()
	if err != nil {
		return "", err
	}

	// Look for go.mod in the current directory and parent directories
	for {
		if _, err := os.Stat(filepath.Join(wd, "go.mod")); err == nil {
			return wd, nil
		}

		parent := filepath.Dir(wd)
		if parent == wd {
			break
		}
		wd = parent
	}

	return "", os.ErrNotExist
}

// findProtoDirs finds all dirs named "proto" under root and returns import paths
func findProtoDirs(protoroot, modulePath string) ([]string, error) {
	moduleRoot, err := findModuleRoot()
	if err != nil {
		return nil, err
	}
	log.Printf("Using module root: %s", moduleRoot)

	protopath := filepath.Join(moduleRoot, protoroot)
	// Validate root exists
	if _, err := os.Stat(protopath); os.IsNotExist(err) {
		return nil, fmt.Errorf("root directory does not exist: %s", protopath)
	}

	var dirs []string
	err = filepath.Walk(protopath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && filepath.Base(path) == "proto" {
			rel, err := filepath.Rel(protopath, path)
			if err != nil {
				return err
			}
			importPath := filepath.ToSlash(filepath.Join(modulePath, protoroot, rel))
			dirs = append(dirs, importPath)
		}
		return nil
	})
	return dirs, err
}

// importAliasFromPath: "internal/validators/http/proto" → "httppb"
func importAliasFromPath(path string) string {
	parts := strings.Split(path, "/")
	if len(parts) < 2 {
		return "pb"
	}
	// Take second-to-last segment (e.g., "http" from "http/proto")
	base := parts[len(parts)-2]
	return base + "pb"
}

// cleanAlias: "httppb" + "Validator" → "HTTPValidator"
func cleanAlias(importAlias, name, protoroot string) string {
	prefix := strings.TrimSuffix(importAlias, "pb")
	if prefix == filepath.Base(protoroot) {
		return name
	}

	prefix = strings.ToUpper(prefix[0:1]) + prefix[1:]

	if strings.Contains(name, "_") {
		parts := strings.Split(name, "_")
		return prefix + strings.Join(parts, "_")
	}
	return prefix + name
}

func processReExports(importReExports map[string][]ReExport, protoroot string) []string {
	var keys []string

	for k, v := range importReExports {
		keys = append(keys, k)
		sort.Slice(v, func(i, j int) bool {
			return v[i].Alias < v[j].Alias
		})
	}

	sort.Strings(keys)

	// Move top-level import to the front
	topLevelImport := protoroot + "/proto"
	for i, v := range keys {
		if strings.HasSuffix(v, topLevelImport) {
			log.Printf("Moving %s to the front", v)
			rest := append(keys[:i], keys[i+1:]...)
			return append([]string{v}, rest...)
		}
	}
	return keys
}

func outputPackageName(out string) (string, error) {
	absOut, err := filepath.Abs(out)
	if err != nil {
		return "", err
	}
	return filepath.Base(filepath.Dir(absOut)), nil
}

func generateTemplateData(protoroot, module, out string) (*TemplateData, error) {
	// Find all proto dirs
	protoDirs, err := findProtoDirs(protoroot, module)
	if err != nil {
		return nil, err
	}

	if len(protoDirs) == 0 {
		return nil, fmt.Errorf("no proto directories found under %s", protoroot)
	}

	log.Printf("Found %d proto directories under %s: %v", len(protoDirs), protoroot, protoDirs)

	// Load packages
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax | packages.NeedDeps,
	}
	pkgs, err := packages.Load(cfg, protoDirs...)
	if err != nil {
		return nil, err
	}

	data := &TemplateData{
		Root:            protoroot,
		Module:          module,
		ImportReExports: map[string][]ReExport{},
	}

	data.OutPackage, err = outputPackageName(out)
	if err != nil {
		return nil, err
	}

	importMap := map[string]string{}

	for _, pkg := range pkgs {
		log.Printf("Processing package %s", pkg.PkgPath)

		importPath := pkg.PkgPath
		importAlias := importAliasFromPath(importPath)
		importMap[importPath] = importAlias

		data.Imports = append(data.Imports, Import{
			Alias: importAlias,
			Path:  importPath,
		})

		scope := pkg.Types.Scope()
		for _, name := range scope.Names() {
			obj := scope.Lookup(name)
			if obj == nil || !token.IsExported(name) {
				continue
			}

			// Only message types (structs)
			if _, ok := obj.Type().Underlying().(*types.Struct); !ok {
				continue
			}

			if strings.HasPrefix(name, "XXX_") {
				continue
			}

			alias := cleanAlias(importAlias, name, protoroot)
			data.ImportReExports[importPath] = append(data.ImportReExports[importPath], ReExport{
				Alias:       alias,
				Original:    name,
				ImportAlias: importAlias,
			})
		}
	}

	// Sort imports
	sort.Slice(data.Imports, func(i, j int) bool {
		return data.Imports[i].Alias < data.Imports[j].Alias
	})
	data.ReExportOrder = processReExports(data.ImportReExports, protoroot)

	return data, nil
}

func main() {
	flag.Parse()
	if *protoroot == "" || *out == "" || *module == "" {
		flag.Usage()
		os.Exit(1)
	}

	// Create output file
	f, err := os.Create(*out)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	data, err := generateTemplateData(*protoroot, *module, *out)
	if err != nil {
		log.Fatal(err)
	}

	err = tmpl.Execute(f, data)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Generated %s: Added types from %d imports\n", *out, len(data.Imports))
}
